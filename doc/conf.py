# Configuration file for the Sphinx documentation builder
# -------------------------------------------------------
#
# This file does only contain a selection of the most common options.
# More info:  http://www.sphinx-doc.org/en/master/config


import os
import shutil
import sys

# -- Variables ----------------------------------------------------------------

DOC_DIR = os.path.abspath(os.path.dirname(__file__))
"""This directory"""

PROJECT_DIR = os.path.dirname(DOC_DIR)
"""The root project directory"""

COPY_FILES: list = [
    ("README.md", "doc/install.md"),
]
"""Files to copy in format (source, target) relative to PROJECT_DIR.

NOTE If adding files here, make sure to add them to .gitignore as well!"""


# -- Path setup ---------------------------------------------------------------
# Insert the project directory into the system PATH such that utopya and all
# other packages become accessible and importable for sphinx.
# This is important for autodoc etc.
sys.path.insert(0, PROJECT_DIR)


# -- Function definitions -----------------------------------------------------


def _str2bool(val: str):
    """Copy of strtobool from deprecated distutils package"""
    val = val.lower()
    if val in ("y", "yes", "t", "true", "on", "1"):
        return True
    elif val in ("n", "no", "f", "false", "off", "0"):
        return False
    raise ValueError(f"Invalid truth value {repr(val)}!")


def find_version(*file_paths) -> str:
    """Tries to extract a version from the given path sequence"""
    import codecs
    import os
    import re

    def read(*parts):
        """Reads a file from the given path sequence, relative to this file"""
        here = os.path.abspath(os.path.dirname(__file__))
        with codecs.open(os.path.join(here, *parts), "r") as fp:
            return fp.read()

    # Read the file and match the __version__ string
    file = read(*file_paths)
    match = re.search(r"^__version__\s?=\s?['\"]([^'\"]*)['\"]", file, re.M)
    if match:
        return match.group(1)
    raise RuntimeError("Unable to find version string in " + str(file_paths))


# -- Project information ------------------------------------------------------

project = "utopya"
copyright = "2018 — 2025, utopya developers"
author = "utopya developers"

# The short X.Y version
version = find_version("..", "utopya", "__init__.py")

# The full version, including alpha/beta/rc tags
release = find_version("..", "utopya", "__init__.py")


# -- General configuration ----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
needs_sphinx = "5.3"

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.autodoc.typehints",
    "sphinx.ext.intersphinx",
    "sphinx.ext.todo",
    "sphinx.ext.doctest",
    "sphinx.ext.coverage",
    "sphinx.ext.mathjax",
    "sphinx.ext.ifconfig",
    "sphinx.ext.viewcode",
    #
    # -- Additional extensions...
    #
    #   ... to allow toggling content
    "sphinx_togglebutton",
    #
    #   ... to allow Markdown syntax
    "myst_parser",
    #
    #   ... to automatically show the click CLI
    "sphinx_click",
    #
    #   ... to pre-process Google-style Python docstrings
    "sphinx.ext.napoleon",
    #
    #   ... to have the IPython directive available for code examples
    "IPython.sphinxext.ipython_console_highlighting",
    "IPython.sphinxext.ipython_directive",
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = {
    ".rst": "restructuredtext",
    ".md": "markdown",
}

# The master toctree document.
master_doc = "index"

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = "en"

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = None


# -- Configuration for API reference generation -------------------------------

autodoc_default_options = {
    "members": True,
    "member-order": "bysource",
    "undoc-members": True,
    "private-members": True,
    "inherited-members": False,  # get unresolvable references otherwise
}


# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = "sphinx_book_theme"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#
# NOTE issues button and edit page buttons not working with GitLab repos yet
html_theme_options = {
    "repository_url": "https://gitlab.com/utopia-project/utopya",
    "use_repository_button": True,
    "use_issues_button": False,
    "use_edit_page_button": False,
    "use_download_button": True,
    "use_fullscreen_button": False,
}


# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

# Custom CSS files, assumed one of `html_static_path`
html_css_files = ["css/custom.css"]

# Custom sidebar templates, must be a dictionary that maps document names
# to template names.
#
# The default sidebars (for documents that don't match any pattern) are
# defined by theme itself.  Builtin themes are using these templates by
# default: ``['localtoc.html', 'relations.html', 'sourcelink.html',
# 'searchbox.html']``.
#
# html_sidebars = {}


# Title, Logo, Favicon
#
html_title = ""
html_logo = "_static/img/logo_green.svg"
html_favicon = "_static/img/icon_green.png"


# -- Options for HTMLHelp output ----------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = "utopyadoc"


# -- Options for LaTeX output -------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #
    # 'papersize': 'letterpaper',
    # The font size ('10pt', '11pt' or '12pt').
    #
    # 'pointsize': '10pt',
    # Additional stuff for the LaTeX preamble.
    #
    # 'preamble': '',
    # Latex figure (float) alignment
    #
    # 'figure_align': 'htbp',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (
        master_doc,
        "utopya.tex",
        "utopya Documentation",
        "utopya developers",
        "manual",
    ),
]


# -- Options for manual page output -------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [(master_doc, "utopya", "utopya Documentation", [author], 1)]


# -- Options for Texinfo output -----------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (
        master_doc,
        "utopya",
        "utopya Documentation",
        author,
        "utopya",
        "Simulation and evaluation management for Utopia",
        "Research Software",
    ),
]


# -- Options for Epub output --------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = project

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#
# epub_identifier = ''

# A unique identification for the text.
#
# epub_uid = ''

# A list of files that should not be packed into the epub file.
epub_exclude_files = ["search.html"]


# -----------------------------------------------------------------------------
# -- Extension configuration --------------------------------------------------
# -----------------------------------------------------------------------------

# -- Options for todo extension -----------------------------------------------

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = True


# -- Napoleon configuration ---------------------------------------------------

napoleon_google_docstring = True
# Whether to parse Google style docstrings. (default: true)

napoleon_numpy_docstring = False
# Whether to parse numpy style docstrings. (default: true)

napoleon_include_init_with_doc = True
# True to list __init___ docstrings separately from the class docstring.
# False to fall back to Sphinx’s default behavior, which considers the
# __init___ docstring as part of the class documentation. Defaults to False.

napoleon_include_private_with_doc = False
# True to include private members (like _membername) with docstrings in the
# documentation. False for Sphinx’s default behavior. Default: False

napoleon_include_special_with_doc = True
# True to include special members (like __membername__) with docstrings in the
# documentation. False to fall back to Sphinx’s default behavior. Default: True


# -- MyST ---------------------------------------------------------------------
# See docs for more info:
#   https://myst-parser.readthedocs.io/en/latest/configuration.html
#
myst_enable_extensions = [
    "amsmath",
    # "colon_fence",
    # "deflist",
    # "dollarmath",
    # "fieldlist",
    # "html_admonition",
    # "html_image",
    "linkify",
    # "replacements",
    "smartquotes",
    "strikethrough",
    # "substitution",
    # "tasklist",
]


# -- IPython Configuration ----------------------------------------------------
# See https://ipython.readthedocs.io/en/stable/sphinxext.html

# NOTE Using default values.


# -- Intersphinx --------------------------------------------------------------

# Mappings can be looked up from the following GitHub gist:
#   https://gist.github.com/bskinn/0e164963428d4b51017cebdb6cda5209
#
# Further documentation:
#   https://docs.readthedocs.io/en/stable/guides/intersphinx.html
#   https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html
#
# In case reference targeting fails, consider using the sphobjinv package
#   https://github.com/bskinn/sphobjinv

# fmt: off
intersphinx_mapping = {
    #
    # First-party docs:
    "paramspace":   ("https://paramspace.readthedocs.io/en/latest/", None),
    "yayaml":       ("https://yayaml.readthedocs.io/en/latest/", None),
    "dantro":       ("https://dantro.readthedocs.io/en/latest/", None),
    #
    # Third-party docs
    "python":       ("https://docs.python.org/3/", None),
    "sphinx":       ("https://www.sphinx-doc.org/en/master/", None),
    "h5py":         ("https://docs.h5py.org/en/latest/", None),
    "matplotlib":   ("https://matplotlib.org/stable/", None),
    "seaborn":      ("https://seaborn.pydata.org", None),
    "numpy":        ("https://numpy.org/doc/stable/", None),
    "pandas":       ("https://pandas.pydata.org/docs/", None),
    "scipy":        ("https://docs.scipy.org/doc/scipy/", None),
    "xarray":       ("https://docs.xarray.dev/en/stable/", None),
    "dask":         ("https://docs.dask.org/en/stable/", None),
    "networkx":     ("https://networkx.org/documentation/stable/", None),
    "sympy":        ("https://docs.sympy.org/latest/", None),
    "dill":         ("https://dill.readthedocs.io/en/latest/", None),
    "pytest":       ("https://pytest.org/en/stable/", None),
    "pydantic":     ("https://docs.pydantic.dev/latest/", None),
    #
    # Broken:
    # "ruamel.yaml":  ("https://yaml.readthedocs.io/en/latest/", None),
}
# fmt: on

# Allow deactivating TLS verification because some intersphinx servers have
# certificate issues, even temporary ones, which make the build process less
# robust in CI.
tls_verify = _str2bool(os.environ.get("SPHINX_TLS_VERIFY", "yes"))


# -- Nitpicky Configuration ---------------------------------------------------

# Be nitpicky about warnings, to show all references where the target could
# not be found
nitpicky = True
nitpick_ignore = []
nitpick_ignore_regex = []

# ... however, we need to exclude quite a lot, so we load the to-be-ignored
# references from a file. This is a list of (type, target) tuples, both entries
# being strings, e.g. `('py:func', 'int')`.
#
# The individual entries can also be regex patterns. To add an entry to the
# regex list instead of the non-regex list, prefix a line with "re: ", e.g.:
#
#       re: py:func ^int$
#
# See the following page for more information and syntax:
#  www.sphinx-doc.org/en/master/usage/configuration.html#confval-nitpick_ignore

for line in open(".nitpick-ignore"):
    line = line.strip()
    if not line or line.startswith("#"):
        continue

    if line.startswith("re: "):
        _, reftype, target = line.split(" ", 2)
        nitpick_ignore_regex.append((reftype, target.strip()))

    else:
        reftype, target = line.split(" ", 1)
        nitpick_ignore.append((reftype, target.strip()))


# -----------------------------------------------------------------------------
# -- Functions used in sphinx setup function ----------------------------------
# -----------------------------------------------------------------------------


def run_apidoc(_):
    """A function to run apidoc, creating the API documentation"""
    from sphinx.ext import apidoc

    # Get the required directory paths
    cur_dir = os.path.abspath(os.path.dirname(__file__))
    out_dir = os.path.join(cur_dir, "api")
    modules = [
        os.path.join(cur_dir, "..", "utopya"),
        os.path.join(cur_dir, "..", "utopya_backend"),
    ]
    shared_argv = [
        "--force",
        # "--separate",
        "--private",
        "--module-first",
        "--no-toc",
        "-o",
        out_dir,
    ]

    for module in modules:
        apidoc.main(shared_argv + [module])


# .. Copying files ............................................................


def copy_files(files: list = COPY_FILES):
    """Copies files relative to the PROJECT_DIR"""
    for src, dest in files:
        shutil.copy2(
            os.path.join(PROJECT_DIR, src),
            os.path.join(PROJECT_DIR, dest),
        )


# .. Manipulating source ......................................................


def manipulate_source_read(app, docname: str, source: list):
    """Manipulates individual files according to some rules.

    - Cut out the relevant sections from the main readme file in order to
      reduce duplicated content.

    .. note::

        ``source`` contains a *single* entry that is the full page source as a
        string, including all line break characters. Manipulation of the
        source can be done by *mutably* changing that single entry in the
        ``source`` object (a list).
    """
    if docname == "install":
        # This file is the copied readme file; but we only want the
        # installation instructions.
        # We need a few markers to get the relevant parts ...
        marker_start = "<!-- start: installation -->"
        marker_end = "<!-- end: installation -->"
        marker_links = "<!-- start: links -->"

        new_start = source[0].find(marker_start) + len(marker_start)
        new_end = source[0].find(marker_end)
        links_start = source[0].find(marker_links) + len(marker_links)
        print(new_start, new_end, links_start)

        source[0] = source[0][new_start:new_end] + source[0][links_start:]
        return

    # NOTE Can add more here


# .. Figure generation ........................................................


def generate_figures():
    """Generates output from scripts in a certain module"""

    # Check environment variable
    TOGGLE_ENVVAR = "UTOPYA_DOC_GENERATE_FIGURES"
    print(
        f"Checking {TOGGLE_ENVVAR} environment variable for "
        "whether figures should be generated ..."
    )
    if not os.environ.get(TOGGLE_ENVVAR) or not _str2bool(
        os.environ.get(TOGGLE_ENVVAR, "False")
    ):
        print(
            f"Not generating figures. Set the {TOGGLE_ENVVAR} "
            "environment variable to control this behavior.\n\n"
        )
        return

    # Generate paths
    gen_fig_dir = os.path.join(DOC_DIR, "..", "tests", "_gen_figures")
    out_dir = os.path.join(DOC_DIR, "_static", "_gen")

    # Set environment variables such that test output ends up in the desired
    # output directory. The abbreviated path means that not the full module
    # string of the test module is included into the path but only the name of
    # the test function (with the `test_` prefix dropped).
    os.environ["UTOPYA_USE_TEST_OUTPUT_DIR"] = "yes"
    os.environ["UTOPYA_TEST_OUTPUT_DIR"] = str(out_dir)
    os.environ["UTOPYA_ABBREVIATE_TEST_OUTPUT_DIR"] = "yes"
    os.environ["UTOPYA_TEST_VERBOSITY"] = "1"  # to not be overly verbose

    # Let pytest do the rest
    print("Now invoking (pytest-based) figure generation module ...\n")

    import pytest

    rv = pytest.main(["-v", gen_fig_dir])
    if rv != 0:
        raise RuntimeError(
            "Figure generation failed! See error log above for more info."
        )
    print("\nFigure generation finished successfully. Yay :)\n")

    # Give some stats
    num_files = 0
    all_files = []
    for dirpath, dirnames, filenames in os.walk(out_dir):
        rel_dir = os.path.relpath(dirpath, out_dir)
        files = [
            os.path.join(rel_dir, f)
            for f in filenames
            if not f.startswith(".")
        ]
        num_files += len(files)
        all_files += files

    _files = "\n".join(f"  {f}" for f in all_files)
    print(
        f"Output directory\n  {out_dir}\ncontains {num_files} files:\n"
        f"{_files}\n\n"
    )


# -----------------------------------------------------------------------------


def setup(app):
    """A custom sphinx setup function, attaching to sphinx hooks"""
    copy_files()
    generate_figures()

    app.connect("source-read", manipulate_source_read)
    app.connect("builder-inited", run_apidoc)
