#!/usr/bin/env python3
"""This is the command line interface for Utopia"""

import sys
import argparse
import warnings

# Define the CLI
parser = argparse.ArgumentParser(description="Command line access to Utopia.")

# Add sub-parsers to allow sub-commands
subparsers = parser.add_subparsers(dest='mode',
                                   title="commands")
p_run  = subparsers.add_parser('run',
                               help="perform a simulation run")
p_eval = subparsers.add_parser('eval',
                               help="load a finished Utopia run and perform "
                                    "only the evaluation")
p_cfg  = subparsers.add_parser('config',
                               help="set user-specific config options")

# subcommand: run .............................................................
p_run.add_argument('model_name',
                   help="Name of the model to run")
p_run.add_argument('run_cfg_path',
                   default=None, nargs='?',
                   help="Path to the run configuration. If not given, the "
                        "default model configuration is used.")

# single or sweep?
p_run.add_argument('-s', '--single',
                   action='store_true',
                   help="If given, forces a single simulation.")
p_run.add_argument('-p', '--sweep',
                   action='store_true',
                   help="If given, forces a parameter sweep. Is ignored, if "
                        "the --single flag was also given.")

# updating meta configuration
p_run.add_argument('--note',
                   default=None, nargs='?',
                   help="Overwrites the `paths->model_note` entry which is "
                        "used in creation of the run directory path.")
p_run.add_argument('--debug',
                   action='store_true',
                   help="If given, sets a number of configuration parameters "
                        "which make debugging of the model and the associated "
                        "plotting scripts easier, e.g. by lowering the model "
                        "log level to DEBUG and creating tracebacks for "
                        "exceptions in the python scripts. Note that the "
                        "--sim-errors flag takes precedence over what is set "
                        "here.")
p_run.add_argument('--sim-errors',
                   default=None, nargs='?',
                   help="Controls the value of the WorkerManager's "
                        "`nonzero_exit_handling` flag which defines how "
                        "errors in simulations are handled. Allowed values "
                        "are: 'ignore', 'warn', 'raise'. "
                        "If not given, the default from the base config or "
                        "(if set) the user configuration is used.")
p_run.add_argument('--num-steps',
                   default=None, nargs='?', type=int,
                   help="Sets the number of simulation steps to this value.")
p_run.add_argument('--num-seeds',
                   default=None, nargs='?', type=int,
                   help="Creates a parameter dimension for the seeds with the "
                        "given number of seed values.")

# plotting after the run
p_run.add_argument('--no-plot',
                   action='store_true',
                   help="If set, no plots will be created. Note that plotting "
                        "capabilities via the Multiverse or the CLI are not "
                        "yet implemented, thus you will have to do the plots "
                        "manually if you pass this option.") # TODO implement
p_run.add_argument('--plots-cfg',
                   default=None, nargs='?',
                   help="If given, uses the plots configuration file found "
                        "at this path instead of the defaults of the model.")
p_run.add_argument('--plot-only',
                   default=None, nargs='*',
                   help="If given, will plot only those entries of the plot "
                        "configuration that match the names given here.")


# subcommand: eval ............................................................
p_eval.add_argument('model_name',
                    help="Name of the model to evaluate. This is used to find "
                         "the output directory")
p_eval.add_argument('run_dir_path',
                    default=None, nargs='?',
                    help="Path to the run directory that is to be loaded. "
                         "It can be a relative or absolute path, or the "
                         "timestamp (including model note, if present) of the "
                         "directory. If not given, the directory with the "
                         "most recent timestamp is used.")
p_eval.add_argument('--plots-cfg',
                    default=None, nargs='?',
                    help="If given, uses the plots configuration file found "
                         "at this path instead of the defaults of the model.")
p_eval.add_argument('--plot-only',
                    default=None, nargs='*',
                    help="If given, will plot only those entries of the plot "
                         "configuration that match the names given here.")
p_eval.add_argument('--run_cfg_path',
                    default=None, nargs='?',
                    help="Path to the run configuration. Can be used to "
                         "change the configuration of DataManager and "
                         "PlotManager.")
p_eval.add_argument('--debug',
                    action='store_true',
                    help="If given, configures the PlotManager such that it "
                         "raises exceptions instead of warning.")


# subcommand: config ..........................................................
p_cfg.add_argument('--deploy',
                   action='store_true',
                   help="Deploy the user config file (all entries disabled) "
                        "to ~/.config/utopia/user_cfg.yml, asking for further "
                        "action if a file already exists at that location.")
# TODO add --get and --set to easily manipulate entries


# subcommand: TODO ............................................................
# ...



# CLI defined now. Parse the arguments...
args = parser.parse_args()


# -----------------------------------------------------------------------------
# If continuing further, need some imports
from paramspace import ParamDim

import utopya
import utopya.cltools


if __name__ == '__main__':
    # Config subcommand .......................................................
    if args.mode == 'config':
        if args.deploy:
            utopya.cltools.deploy_user_cfg()

        # End here.
        sys.exit()

    # Run & eval subcommands ..................................................
    # NOTE the subcommands only differ in which Multiverse class is created and
    #      whether a run is performed or not

    # Prepare Multiverse
    # Set an empty update dict. It will hold adjustments to the given configs
    update_dict = {}

    # If a model_note was given, add it to the paths
    if args.mode == 'run' and args.note:
        update_dict['paths'] = dict(model_note=args.note)

    # In debug mode, set a number of configuration keys
    if args.debug:
        # NOTE Relies on update_dict not containig the top-level entries that
        #      are set here.

        # Set model log level to DEBUG
        update_dict['parameter_space'] = dict(log_levels=dict(model='debug'))
        
        # Let PlotManager raise exceptions
        update_dict['plot_manager'] = dict(raise_exc=True)

        # Let WorkerManager raise exceptions
        update_dict['worker_manager'] = dict(nonzero_exit_handling='raise')

    # Set the WorkerManager's non-zero exit handling, if in debug mode
    if args.mode == 'run' and args.sim_errors:
        # Check if an entry already exists; if not, need an empty dict there
        if 'worker_manager' not in update_dict:
            update_dict['worker_manager'] = {}
        
        update_dict['worker_manager']['nonzero_exit_handling']=args.sim_errors

    # Set number of simulation steps
    if args.mode == 'run' and args.num_steps:
        if args.num_steps < 0:
            raise ValueError("Argument --num-steps needs to be positive, was "
                             "{}.".format(args.num_steps))

        # Check if key already exists in order to not overwrite anything
        if 'parameter_space' not in update_dict:
            update_dict['parameter_space'] = {}

        update_dict['parameter_space']['num_steps'] = args.num_steps

    # Set seeds to a parameter dimension
    if args.mode == 'run' and args.num_seeds is not None:
        if args.num_seeds < 1:
            raise ValueError("Argument --num-seeds needs to be >= 1, was "
                             "{}.".format(args.num_seeds))

        # Check if key already exists in order to not overwrite anything
        if 'parameter_space' not in update_dict:
            update_dict['parameter_space'] = {}

        seed_pdim = ParamDim(default=42, range=[args.num_seeds])
        update_dict['parameter_space']['seed'] = seed_pdim

    # Preparations finished now
    
    
    # Create Multiverse and perform the run
    if args.mode in ['run']:
        # Instantiate a Multiverse object
        mv = utopya.Multiverse(model_name=args.model_name,
                               run_cfg_path=args.run_cfg_path,
                               **update_dict)

        # Distinguish single and sweep
        if args.single:
            if args.sweep:
                warnings.warn("Received both --single and --sweep command "
                              "line arguments; will perform a single "
                              "simulation.",
                              UserWarning)
                # TODO use utopya-specific warning class

            mv.run_single()

        elif args.sweep:
            mv.run_sweep()

        else:
            mv.run()

        # Only need to continue if plots are to be created
        if args.no_plot:
            sys.exit()


    elif args.mode in ['eval']:
        # Create a frozen Multiverse object that supplies all the necessary
        # structures to load data and plot ...
        mv = utopya.FrozenMultiverse(model_name=args.model_name,
                                     run_dir=args.run_dir_path,
                                     run_cfg_path=args.run_cfg_path,
                                     **update_dict)

    # else: should not occur!

    # Loading and plotting
    # Tell the DataManager to load
    mv.dm.load_from_cfg(print_tree=True)
    # NOTE This will load the data using the utopya default configuration

    # Tell the PlotManager to plot
    mv.pm.plot_from_cfg(plots_cfg=args.plots_cfg, plot_only=args.plot_only)
    # NOTE If plots_cfg was not given, this uses the plot configuration that
    #      belongs to the model. If it is given, the configuration is loaded
    #      from the given file path.
