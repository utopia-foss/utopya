#!/usr/bin/env python3
"""This is the command line interface for Utopia"""

import sys
import argparse
import warnings

# Define the CLI
parser = argparse.ArgumentParser(description="Command line access to Utopia.")

# Add sub-parsers to allow sub-commands
subparsers = parser.add_subparsers(dest='mode',
                                   title="commands")
p_run  = subparsers.add_parser('run',
                               help="perform a simulation run")
p_eval = subparsers.add_parser('eval',
                               help="load a finished Utopia run and perform "
                                    "only the evaluation")
p_cfg  = subparsers.add_parser('config',
                               help="set user-specific config options")

# subcommand: run .............................................................
p_run.add_argument('model_name',
                   help="Name of the model to run")
p_run.add_argument('run_cfg_path',
                   default=None, nargs='?',
                   help="Path to the run configuration. If not given, the "
                        "default model configuration is used.")

# single or sweep?
p_run.add_argument('-s', '--single',
                   action='store_true',
                   help="If given, forces a single simulation.")
p_run.add_argument('-p', '--sweep',
                   action='store_true',
                   help="If given, forces a parameter sweep. Is ignored, if "
                        "the --single flag was also given.")

# updating specific meta configuration entries
p_run.add_argument('--note',
                   default=None, nargs='?',
                   help="Overwrites the `paths->model_note` entry which is "
                        "used in creation of the run directory path.")
p_run.add_argument('--debug',
                   action='store_true',
                   help="If given, sets a number of configuration parameters "
                        "which make debugging of the model and the associated "
                        "plotting scripts easier, e.g. by lowering the model "
                        "log level to DEBUG and creating tracebacks for "
                        "exceptions in the python scripts. Note that the "
                        "--sim-errors flag takes precedence over what is set "
                        "here.")
p_run.add_argument('--sim-errors',
                   default=None, nargs='?',
                   choices=['ignore', 'warn', 'warn_all', 'raise'],
                   help="Controls the value of the WorkerManager's "
                        "`nonzero_exit_handling` flag which defines how "
                        "errors in simulations are handled. Allowed values "
                        "are: 'ignore', 'warn', 'warn_all', 'raise'. "
                        "If not given, the default from the base config or "
                        "(if set) the user configuration is used.")
p_run.add_argument('--num-steps',
                   default=None, nargs='?', type=int,
                   help="Sets the number of simulation steps.")
p_run.add_argument('--write-every',
                   default=None, nargs='?', type=int,
                   help="Sets the root-level `write_every` parameter.")
p_run.add_argument('--num-seeds',
                   default=None, nargs='?', type=int,
                   help="Creates a parameter dimension for the seeds with the "
                        "given number of seed values.")

# arguments for generically updating meta configuration keys
p_run.add_argument('--set-params',
                   default=None, nargs='+', type=str,
                   help="Sets key-value pairs in the `parameter_space` entry "
                        "of the meta configuration. Example: foo.bar=42 sets "
                        "the 'bar' entry in the 'foo' dict to 42. "
                        "Note that multiple parameter can be set at once by "
                        "separating them with a space; if a space needs to be "
                        "in the argument value, put the strings into '...' or "
                        "\"...\".")
p_run.add_argument('--set-cfg',
                   default=None, nargs='+', type=str,
                   help="Like --set-params but attaching to the root level of "
                        "the meta configuration.")

# plotting after the run
p_run.add_argument('--no-plot',
                   action='store_true',
                   help="If set, no plots will be created. Note that plotting "
                        "capabilities via the Multiverse or the CLI are not "
                        "yet implemented, thus you will have to do the plots "
                        "manually if you pass this option.") # TODO implement
p_run.add_argument('--plots-cfg',
                   default=None, nargs='?',
                   help="If given, uses the plots configuration file found "
                        "at this path instead of the defaults of the model.")
p_run.add_argument('--plot-only',
                   default=None, nargs='*',
                   help="If given, will plot only those entries of the plot "
                        "configuration that match the names given here.")


# subcommand: eval ............................................................
p_eval.add_argument('model_name',
                    help="Name of the model to evaluate. This is used to find "
                         "the output directory")
p_eval.add_argument('run_dir_path',
                    default=None, nargs='?',
                    help="Path to the run directory that is to be loaded. "
                         "It can be a relative or absolute path, or the "
                         "timestamp (including model note, if present) of the "
                         "directory. If not given, the directory with the "
                         "most recent timestamp is used.")
p_eval.add_argument('--plots-cfg',
                    default=None, nargs='?',
                    help="If given, uses the plots configuration file found "
                         "at this path instead of the defaults of the model.")
p_eval.add_argument('--plot-only',
                    default=None, nargs='*',
                    help="If given, will plot only those entries of the plot "
                         "configuration that match the names given here.")
p_eval.add_argument('--run_cfg_path',
                    default=None, nargs='?',
                    help="Path to the run configuration. Can be used to "
                         "change the configuration of DataManager and "
                         "PlotManager.")
p_eval.add_argument('--debug',
                    action='store_true',
                    help="If given, configures the PlotManager such that it "
                         "raises exceptions instead of warning.")


# subcommand: config ..........................................................
p_cfg.add_argument('--deploy',
                   action='store_true',
                   help="Deploy the user config file (all entries disabled) "
                        "to ~/.config/utopia/user_cfg.yml, asking for further "
                        "action if a file already exists at that location.")
# TODO add --get and --set to easily manipulate entries


# subcommand: TODO ............................................................
# ...



# CLI defined now. Parse the arguments...
args = parser.parse_args()


# -----------------------------------------------------------------------------
# If continuing further, need some imports
import logging
log = logging.getLogger(__name__)

from paramspace import ParamDim

import utopya
from utopya.tools import pprint
from utopya.cltools import deploy_user_cfg, add_entry, add_from_kv_pairs


if __name__ == '__main__':
    # Config subcommand .......................................................
    if args.mode == 'config':
        if args.deploy:
            deploy_user_cfg()

        # End here.
        sys.exit()

    # Run & eval subcommands ..................................................
    # Prepare arguments for Multiverse . . . . . . . . . . . . . . . . . . . . 

    log.info("Parsing additional command line arguments ...")

    # Set an empty update dict. It will hold adjustments to the given configs
    update_dict = {}
    # NOTE The following updates to the update_dict rely on it being mutable

    # In debug mode, set a number of configuration keys
    if args.debug:
        # Set model log level to DEBUG
        add_entry('debug', add_to=update_dict,
                  key_path=['parameter_space', 'log_levels', 'model'])
        
        # Let PlotManager raise exceptions
        add_entry(True, add_to=update_dict,
                  key_path=['plot_manager', 'raise_exc'])

        # Let WorkerManager raise exceptions
        add_entry('raise', add_to=update_dict,
                  key_path=['worker_manager', 'nonzero_exit_handling'])


    # Additional arguments relevant in run mode
    if args.mode == 'run':
        # If a model_note was given, add it to the paths
        if args.note:
            add_entry(args.note, add_to=update_dict,
                      key_path=['paths', 'model_note'])

        # The WorkerManager's non-zero exit handling, if in debug mode
        if args.sim_errors:
            add_entry(args.sim_errors, add_to=update_dict,
                      key_path=['worker_manager', 'nonzero_exit_handling'])

        # Number of simulation steps
        if args.num_steps:
            add_entry(args.num_steps, add_to=update_dict,
                      key_path=['parameter_space', 'num_steps'],
                      is_valid= lambda v: v >= 0,
                      ErrorMsg= lambda v: ValueError("Argument --num-steps "
                                                     "needs to be positive, "
                                                     "was {}.".format(v)))

        # The root-level write_every parameter
        if args.write_every:
            add_entry(args.write_every, add_to=update_dict,
                      key_path=['parameter_space', 'write_every'],
                      is_valid= lambda v: v >= 1,
                      ErrorMsg= lambda v: ValueError("Argument --write-every "
                                                     "needs to be >= 1, "
                                                     "was {}.".format(v)))

        # Set seeds to a parameter dimension object
        if args.num_seeds is not None:
            add_entry(args.num_seeds,
                      value_func=lambda v: ParamDim(default=42, range=[v]),
                      add_to=update_dict,
                      key_path=['parameter_space', 'seed'],
                      is_valid= lambda v: bool(v > 1),
                      ErrorMsg= lambda v: ValueError("Argument --num-seeds "
                                                     "needs to be > 1, "
                                                     "was {}.".format(v)))

        # Set general configuration entries
        if args.set_params:
            # Add an entry for each pair
            add_from_kv_pairs(*args.set_params,
                              add_to=update_dict['parameter_space'])
    
        if args.set_cfg:
            # Add an entry for each pair
            add_from_kv_pairs(*args.set_params, add_to=update_dict)


    # Finished with generating the update dict; give some info on it
    if update_dict:
        log.info("Updates to meta configuration:\n\n%s", pprint(update_dict))

    # Preparations finished now.
    
    
    # Create Multiverse and perform the run  . . . . . . . . . . . . . . . . . 
    # NOTE the subcommands only differ in which Multiverse class is created and
    #      whether a run is performed or not

    if args.mode in ['run']:
        # Instantiate a Multiverse object
        mv = utopya.Multiverse(model_name=args.model_name,
                               run_cfg_path=args.run_cfg_path,
                               **update_dict)

        # Distinguish single and sweep
        if args.single:
            if args.sweep:
                warnings.warn("Received both --single and --sweep command "
                              "line arguments; will perform a single "
                              "simulation.",
                              UserWarning)
                # TODO use utopya-specific warning class

            mv.run_single()

        elif args.sweep:
            mv.run_sweep()

        else:
            mv.run()

        # Only need to continue if plots are to be created
        if args.no_plot:
            log.debug("Received --no-plot. Exiting now.")
            sys.exit()

        log.info("Simulation run finished.\n")


    elif args.mode in ['eval']:
        # Create a frozen Multiverse object that supplies all the necessary
        # structures to load data and plot ...
        mv = utopya.FrozenMultiverse(model_name=args.model_name,
                                     run_dir=args.run_dir_path,
                                     run_cfg_path=args.run_cfg_path,
                                     **update_dict)

    # else: should not occur!

    # Loading  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
    log.info("Loading data...")

    # Tell the DataManager to load
    mv.dm.load_from_cfg(print_tree=True)
    # NOTE This will load the data using the utopya default configuration

    log.info("Loading data finished.\n")


    # Plotting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
    log.info("Plotting...")

    # Tell the PlotManager to plot
    mv.pm.plot_from_cfg(plots_cfg=args.plots_cfg, plot_only=args.plot_only)
    # NOTE If plots_cfg was not given, this uses the plot configuration that
    #      belongs to the model. If it is given, the configuration is loaded
    #      from the given file path.
    
    log.info("Plotting finished.\n")

    log.info("All done.\n")
