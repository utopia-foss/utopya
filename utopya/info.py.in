"""This CMake-configured module file holds information about the non-python
side of utopia, e.g. information on which model targets are available and what
the paths to their source and binary directories are.

Note that this is not a usual python module, but is merely used to receive and
parse information and make it easily accessible to other utopya modules.
"""

import os
import glob

# Begin of CMake configured variables .........................................
_LAST_CONFIG_TIME = "@CURRENT_TIME@"

_CMAKE_SOURCE_DIR = "@CMAKE_SOURCE_DIR@"
_CMAKE_BINARY_DIR = "@CMAKE_BINARY_DIR@"

_UTOPIA_MODEL_TARGETS = "@UTOPIA_MODEL_TARGETS@"
_UTOPIA_MODEL_BINPATHS = "@UTOPIA_MODEL_BINPATHS@"
_UTOPIA_MODEL_SRC_DIRS = "@UTOPIA_MODEL_SRC_DIRS@"
# End of CMake configured variables ...........................................

def parse_model_info() -> dict:
    """Using the constants available on the module level, parses them to a dict
    that contains information about all registered Utopia models.

    The dictionary has as keys the model names.
    The entries are again dicts and include the keys `binpath` and `src_dir`.
    
    Returns:
        dict: The model info dictionary
    """

    if not _UTOPIA_MODEL_TARGETS or not _UTOPIA_MODEL_BINPATHS:
        # No models present
        return {}

    # Parse the CMake-syntax lists
    targets = _UTOPIA_MODEL_TARGETS.split(";")
    rel_bin_paths = _UTOPIA_MODEL_BINPATHS.split(";")
    rel_src_paths = _UTOPIA_MODEL_SRC_DIRS.split(";")

    if (   len(targets)       != len(rel_bin_paths)
        or len(targets)       != len(rel_src_paths)
        or len(rel_bin_paths) != len(rel_src_paths)):
        raise ValueError("Utopia model information lists need to be of the "
                         "same length, but were:\n"
                         "targets: {}\n"
                         "rel. binary paths: {}\n"
                         "rel. source paths: {}"
                         "".format(targets, rel_bin_paths, rel_src_paths))

    # Get binary and source dir, of which the above paths are relative to
    bin_dir = _CMAKE_BINARY_DIR
    src_dir = _CMAKE_SOURCE_DIR

    # Populate model info with target names and model info dict
    # This dict comprehension also creates absolute paths
    model_info = {t:dict(binpath=os.path.join(bin_dir, bp),
                         src_dir=os.path.join(src_dir, sd))
                  for t, bp, sd in zip(targets, rel_bin_paths, rel_src_paths)}

    # Extend model information
    for target, _info in model_info.items():
        # Get the source directory
        src_dir = _info['src_dir']

        # Add keys for certain additional files
        for key, suffix, required in [("model_cfg", "_cfg.yml", True),
                                      ("plots_cfg", "_plots.yml", False),
                                      ]:
            # Generate the path to search for the file at
            path = os.path.join(src_dir, target + suffix)

            # Check if it exists
            if os.path.exists(path):
                # Yes. Add the path to the dict
                _info[key] = path

            elif required:
                # Nope, but was required. Raise an error.
                raise FileNotFoundError("For target '{}', could not find "
                                        "required '{}' file at: {}"
                                        "".format(target, key, path))

            else:
                # Does not exist, but is not required either. Still add the key
                _info[key] = None

    return model_info

# Make the model information available to other modules via:
MODELS = parse_model_info()
