---
# Multiverse configuration ....................................................
# Output paths
paths:
  # base output directory
  out_dir: ~/utopia_output

  # model note is added to the output directory path
  model_note: ~

  # From the two above, the run directory will be created at:
  # <out_dir>/<model_name>/<timestamp>-<model_note>/
  # With subfolders: config, eval, universes

  # Whether to save all involved config files granularly, i.e. one by one.
  # If false, only the resulting meta_cfg is saved to the config subdirectory.
  backup_involved_cfg_files: true

# Whether to perfom a parameter sweep
perform_sweep: false
# NOTE This will be ignored if run_single or run_sweep are called directly


# Worker Manager ..............................................................
worker_manager:
  # specify how many processes work in parallel
  # auto : number of processor cores. For values <= 0: #CPUs - num_workers
  num_workers: auto

  # delay between polls [seconds]
  poll_delay: 0.05

  # how to react upon a simulation exiting with non-zero exit code
  nonzero_exit_handling: warn
  # can be: ignore, warn, raise

  # report format specifications at different points of the WM's operation
  rf_spec:
    while_working: while_working
    task_spawned: while_working
    task_finished: while_working
    after_work: after_work
    after_abort: after_work
  # These entries can also be lists, leading to multiple reports being invoked
  # in the specified format.
  # To add report formats, specify them under reporter.report_formats


# Configuration for the WorkerManager.start_working method
run_kwargs:
  # Total timeout (in s) of a run; to ignore, set to ~
  timeout: ~

  # A list of StopCondition objects to check during the run _for each worker_
  # The entries of the following list are OR-connected, i.e. it suffices that
  # one is fulfilled for the corresponding worker to be stopped
  stop_conditions: ~
  # EXAMPLE:
    # - !stop-condition
    #   name: single simulation timeout
    #   description: terminates a worker if it ran for too long
    #   enabled: true  # also the default value
    #   to_check:
    #     # The functions specified here are AND-connected, i.e.: _all_
    #     # need to return True for the stop condition to be fulfilled
    #     - func_name: timeout_wall
    #       # will look for utopya.stopcond._sc_timeout_wall method
    #       seconds: !expr 60*10
    #       # further arguments to utopya.stopcond._sc_timeout_wall


# The defaults for the worker_kwargs
# These are passed to the setup function of each WorkerTask before spawning
worker_kwargs:
  # Whether to save the streams of each Universe to a log file
  save_streams: true
  
  # Whether to forward the streams to stdout
  forward_streams: true
  # can be: true, false, or 'in_single_run' (print only in single runs)

  # The log level at which the streams should be forwarded to stdout
  streams_log_lvl: ~  # if None, uses print instead of the logging module

  # Changes to entries below here have not been tested!
  popen_kwargs: {}

# Reporter ....................................................................
reporter:
  report_formats:
    while_working:
      parser: progress_bar
      show_times: True
      write_to: stdout_noreturn
      min_report_intv: 0.5

    after_work:
      parser: progress_bar
      show_times: True
      write_to: stdout_noreturn


# Data Manager ................................................................
data_manager:
  # Where to create the output directory for this DataManager, relative to
  # the run directory of the Multiverse.
  out_dir: eval/{date:}
  # The {date:} placeholder is replaced by the current timestamp such that
  # future DataManager instances that operate on the same data directory do
  # not create collisions.

  # Supply a default load configuration for the DataManager
  load_cfg:
    # Load the frontend configuration files from the config/ directory
    # Each file refers to a level of the configuration that is supplied to
    # the Multiverse: base <- user <- model <- run <- update
    cfg:
      loader: yaml
      glob_str: 'config/*.yml'
      required: true
      path_regex: config/(\w+)_cfg.yml
      target_path: cfg/{match:}

    # Load the configuration files that are generated for _each_ simulation
    # These hold all information that is available to a single simulation and
    # are in an explicit, human-readable form.
    uni_cfg:
      loader: yaml
      glob_str: universes/uni*/config.yml
      required: true
      path_regex: universes/uni(\d+)/config.yml
      target_path: uni/{match:}/cfg

    # Load the binary output data from each simulation.
    data:
      loader: hdf5_proxy
      glob_str: universes/uni*/data.h5
      required: true
      path_regex: universes/uni(\d+)/data.h5
      target_path: uni/{match:}/data

    # The resulting data tree is then:
    #  └┬ cfg
    #     └┬ base
    #      ├ meta
    #      ├ model
    #      ├ run
    #      └ update
    #   └ uni
    #     └┬ 0
    #        └┬ cfg
    #         └ data
    #           └─ ...         
    #      ├ 1
    #      ...


# Plot Manager ................................................................
plot_manager: {}


# Parameter Space .............................................................
# Only add values here that are independent of models.
# For model-specific configuration, use the model configuration.
parameter_space: {}
